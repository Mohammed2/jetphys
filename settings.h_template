// Purpose: Analysis settings for jet physics package
// Author:  mikko.voutilainen@cern.ch
// Co-author: hannu.siikonen@cern.ch
// Created: June 1, 2015

// All the settings variables are in global name space
// To avoid conflicts, and to make them easier to find
// global variables all start with _jp_ (for JetPhysics)

#ifndef __settings_h__
#define __settings_h__
#include <map>
#include <vector>
#include <string>
#include <set>
#include <iostream>
#include <fstream>
#include <sstream>
#include <regex>
#include <algorithm>
#include <cassert>
#include <cstdio>

using std::map;
using std::vector;
using std::string;
using std::cout;
using std::endl;
using std::regex;


constexpr bool strings_equal(char const * a, char const * b) {
  return *a == *b and (*a == '\0' or strings_equal(a + 1, b + 1));
}


// Debugging info
constexpr bool _jp_debug = false;
// Will assert be used in the programs?
#define USEASSERT // CAUTION: this is an expert option - comment this if you are certain that no problems occur. More than 1/3 off the run time.

//{ BEGIN fundamental file settings
// Do we use CHS jets? ("CHS" for yes, "", for legacy/no)
constexpr const char _jp_chs[] = "CHS";
// Algorithm to use ("AK4PF" or "AK8PF" + "chs" for chs jets)
constexpr const char _jp_algo[] = "AK4PFchs";
// Data type ("DATA", "MC", or "HW")
constexpr const char _jp_type[] = "MC";
// In case of DATA, choose run ("RunB/C/D/E/Fearly/Flate/G/H")
constexpr const char _jp_run[] = "RunB16_Eng";
// Simple helper
constexpr bool _jp_isdt = strings_equal(_jp_type,"DATA");
constexpr bool _jp_ismc = !_jp_isdt;
constexpr bool _jp_ispy = strings_equal(_jp_type,"MC");
constexpr bool _jp_ishw = strings_equal(_jp_type,"HW");
//} END fundamental settings


//{ BEGIN run settings
// Number of events to process (-1 for all)
constexpr Long64_t _jp_nentries =
-1; // all
//10; // debug
//100; //debug
//1000;
//10000; // shorter test run
//100000; // short test run
//1000000; // shortish test run
//100000000;
// Number of events to skip from the beginning (for debugging)
constexpr Long64_t _jp_nskip = 0;
// Step between events
constexpr Long64_t _jp_skim = 0; // "prescale", off if zero
// Only load selected branches (large speedup, but be careful!)
constexpr bool _jp_quick = true;
// Save the infos at times. Setting this to true might help with long runs. (Not recommended
constexpr bool _jp_save = false;
//} END run settings


//{ BEGIN A group of constexpr switches and their settings to turn some parts of the code on/off
// If the output files grow too much, processing becomes more difficult.

// Produce run-level histograms
constexpr bool _jp_doRunHistos = false; // Not needed very often
// Produce basic set of histograms
constexpr bool _jp_doBasicHistos = true;
// Produce full-eta TH3 histograms
constexpr bool _jp_doEtaHistos = true;
// Special reco/gen histos in mc
constexpr bool _jp_doEtaHistosMcResponse = false; // Special studies
// Toggle 3D asymmetry and mpf histos off, if too much space is consumed
constexpr bool _jp_do3dHistos = true;
// Toggle phi histograms
constexpr bool _jp_doPhiHistos = true;

// QGL studies by Ozlem (use an external file for qgl studies)
constexpr bool _jp_doqglfile = false;
constexpr const char _jp_qglfile[] = "output-DATA_RunGfullpart-1.root";

// At some point of time Kostas stored UNCORRECTED four-vector. Current status: CORRECTED
// NOTE: this is a source of constant anxiety, should be rechecked from time to time
constexpr bool _jp_undojes = true;
// We can choose also not to apply the new jes onto a four-vector
constexpr bool _jp_redojes = true;
// For debugging
constexpr bool _jp_skipl2l3res = false;

// Reapply json selection based on the latest one (check lumicalc if false!).
constexpr bool _jp_dojson = true;
constexpr const char _jp_json[] = "lumicalc/Cert_271036-284044_13TeV_23Sep2016ReReco_Collisions16_JSON.txt";
//const constexpr char _jp_json[] = "lumicalc/Cert_294927-306462_13TeV_PromptReco_Collisions17_JSON.txt";

// Calculate luminosity on the fly based on .csv file and take only events with non-zero luminosity.
constexpr bool _jp_dolumi = true;
constexpr const char _jp_lumifile[] = "lumicalc/brilcalc_lumibyls16.csv";
//const constexpr char _jp_lumifile[] = "lumicalc/brilcalc_lumibyls17.csv";

// Add prescale information from a file
constexpr bool _jp_doprescale = false; // CAUTION, this shouldn't be nowadays necessary
constexpr const char _jp_prescalefile[] = "pileup/prescales74x.txt";

constexpr bool _jp_dotrpufile = false; // CAUTION, the histo file in the repo is 2015
constexpr const char _jp_trpufile[] = "pileup/MUperLSvsRUN_MB.root";

// Decide whether or not to simulate triggers from MC (this is slow)
constexpr bool _jp_domctrigsim = true;
// Use "mc" trigger for whole pT range instead of stiching triggers together in histosCombine (false requires trigsim)
constexpr bool _jp_usemctrig = false;

// This is the 13 TeV 25 ns list of triggers (Run2016BCDEFG)
// Check the recommended settings from https://twiki.cern.ch/twiki/bin/view/CMS/InclusiveJetsLegacy
constexpr const char* _jp_triggers[] = // CAUTION: In 2016 jt450 is unprescaled but in 2017 it is not (jt500 and jt550!)
  {"jt40",    "jt60",    "jt80",   "jt140",   "jt200",   "jt260",   "jt320",   "jt400",  "jt450"}; // "jt500"};
constexpr unsigned int _jp_notrigs = sizeof(_jp_triggers)/sizeof(_jp_triggers[0]);
// reference trigger for PU profile in the mc folder and for trigger lumi weighting
constexpr const char _jp_reftrig[] = "jt450"; // "jt500";
// Thresholds for the corresponding triggers (same as in trigger name)
constexpr const double _jp_trigthr[] =
  {40,        60,        80,       140,       200,       260,       320,       400,      450}; // 500};
// Trigger ranges (differ from thresholds)
constexpr const double _jp_trigranges[][2] = {
  {0,84}, {84,114}, {114,196}, {196,272}, {272,330}, {330,395}, {395,468}, {468,548}, {548,6500}
}; // V[5,6], AK4


// Trigger lumis for weighting
constexpr bool _jp_usetriglumi = true; // use luminosity numbers below, in /ub
constexpr const double _jp_triglumi[] = // in /ub
// 2016 final: brilcalc lumi -i /afs/cern.ch/cms/CAF/CMSCOMM/COMM_DQM/certification/Collisions16/13TeV/ReReco/Final/Cert_271036-284044_13TeV_23Sep2016ReReco_Collisions16_JSON.txt --byls --normtag=$PWD/../../../Normtags/normtag_DATACERT.json --minBiasXsec 80000 --hltpath="HLT_PFJet*" -o brilcalc_lumibyls16.csv
  {264821.835,718829.826,2733420.74,23966019.286,102854094.409,587728815.19,1753996573.885,5141160409.826,35860066023.522};
// 2017 final: brilcalc lumi -i /afs/cern.ch/cms/CAF/CMSCOMM/COMM_DQM/certification/Collisions17/13TeV/Final/Cert_294927-306462_13TeV_PromptReco_Collisions17_JSON.txt --byls --normtag=/eos/user/h/hsiikone/Normtags/normtag_BRIL.json --minBiasXsec 80000 --hltpath="HLT_PFJet*" -o brilcalc_lumibyls17.csv
// {480907.381,1135408.863,4300901.657,39784735.913,218494113.161,553531633.649,1402704877.698,4201460774.775,10434425834.42,41366526620.215};
// Unprescaled luminosity for plots
constexpr double _jp_lumi = _jp_triglumi[_jp_notrigs-1]/1000000000.0; // in /fb
// CAUTION: The next are expert options and better to leave untouched if one does not know exactly what is going on.
// Overrides the above routines with a more intricate weighting scheme. When this is on, output-*1.root is weighted. This setting eliminates the use of trigger weight in the normalize step.
constexpr bool _jp_useversionlumi = true;
// In the version treatment we give the weights directly to induce better comparability
constexpr const double _jp_trigwgts[][_jp_notrigs+1] = {
// 2016 values: (jt40-jt450; jt500)
  {143355.7346, 38736.1730,  3686.8700,  695.0398, 154.0182, 36.7479, 11.2671, 4.6109, 1.0000, 1.0000}, // ID = 0, relwgt = 1.0
  {119853.8204, 41465.1988, 13160.4227, 1287.5050, 261.4051, 55.0337, 19.0746, 6.2291, 1.0000, 1.0000}, // ID = 1, relwgt = 5.39
  {154096.5599, 61326.3781, 21207.7739, 2097.7643, 632.5377, 73.5695, 24.3681, 8.2197, 1.0000, 1.0000}, // ID = 2, relwgt = 3.46
  {145927.3361, 65350.8352, 21577.5503, 2240.3264, 676.3622, 77.2779, 25.7789, 8.7586, 1.0000, 1.0000}, // ID = 3, relwgt = 3.11
  {135412.0442, 49886.7252, 13119.1168, 1496.2880, 348.6499, 61.0146, 20.4448, 6.9751, 1.0000, 1.0000}  // ID = 4, relwgt = 12.97 (all)
// 2017 values: (jt40-jt500; jt550)
//   { 33987.8463, 180033.5913, 24589.5675,  293.1822,  32.9817, 52.5539, 20.9513,  5.2989, 1.0390, 1.0000, 1.0000}, // ID = 0, relwgt = 3.43
//   {176155.5860, 180125.1062, 26367.3106,  730.7412, 155.4138, 60.4216, 23.8383,  6.2582, 1.1547, 1.0000, 1.0000}, // ID = 1, relwgt = 2.19
//   {175046.8066,  57831.7848, 15004.4781, 1159.0313, 287.4614, 78.6458, 31.0582, 10.5627, 6.0010, 1.0000, 1.0000}, // ID = 2, relwgt = 1.47
//   {196572.1671,  57551.1125, 16693.6441, 1277.4314, 306.0167, 82.3878, 33.8413, 11.4001, 6.4202, 1.0000, 1.0000}, // ID = 3, relwgt = 5.78
//   {136013.1519,  28134.9096,  1874.0816, 1316.3058, 311.1567, 58.5666, 22.9324,  7.4752, 4.4639, 1.0000, 1.0000}, // ID = 4, relwgt = 4.00
//   { 16079.7095,   9852.0623,  6955.8940,  961.2579, 255.4068, 57.8961, 22.7200,  8.4749, 4.5904, 1.0000, 1.0000}, // ID = 5, relwgt = 3.34
//   {158460.4298,  39504.0196, 16367.6216, 1505.6297, 353.8755, 87.3505, 34.4524, 12.5236, 6.9509, 1.0000, 1.0000}, // ID = 6, relwgt = 23.96
//   {181374.8038,  50159.3910, 14633.4188, 1157.6916, 210.2565, 76.1716, 28.2483,  9.8028, 5.3040, 1.0000, 1.0000}, // ID = 7, relwgt = 3.25
//   {182659.7240,  51593.9726, 14865.8622, 1181.8289, 218.2535, 68.4878, 27.6038,  9.9540, 5.3705, 1.0000, 1.0000}, // ID = 8, relwgt = 1.00
//   { 86017.6580,  36433.1546,  9618.1057, 1039.7587, 189.3256, 71.5339, 29.4905,  9.8457, 3.9644, 1.0000, 1.0000}  // ID = 9, relwgt = 48.42 (all)
};
constexpr const unsigned int _jp_notrigIDs = sizeof(_jp_trigwgts)/sizeof(_jp_trigwgts[0])-1; // Excluding all

// A mapping from "triggerthreshold(pt)_triggerversion" to ID (i.e. the ID of the common group).
// The last ID is not shown here, as it is a summary of all the version functioning together.
const vector< vector<regex> > _jp_trigtags = {
// 2016 values:
  {regex("(40|60|80|140|200|260|320|400|450|500)_4")},                    // ID = 0
  {regex("(40|60|80|140|200|260|320|400|450|500)_5"),regex("(40|60)_6")}, // ID = 1
  {regex("(80|140|200)_6"),regex("(40|60|260|320|400|450|500)_7")},       // ID = 2
  {regex("(80|140|200)_8"),regex("(40|60|260|320|400|450|500)_9")}        // ID = 3
  // 2017 values:
//   {regex("(40|60|450|500)_(10|11)"),regex("80_(9|10)",regex("(140|200)_9"),regex("(260|320|400)_10"),regex("550_1")}, // ID = 0
//   {regex("(40|60|450|500)_12"),regex("(80|260|320|400)_11"),regex("(140|200)_10"),regex("550_2")},                    // ID = 1
//   {regex("(40|60|450|500)_13"),regex("(80|260|320|400)_12"),regex("(140|200)_11"),regex("550_3")},                    // ID = 2
//   {regex("(40|60|450|500)_14"),regex("(80|260|320|400)_13"),regex("(140|200)_12"),regex("550_4")},                    // ID = 3
//   {regex("(40|60|450|500)_15"),regex("(80|260|320|400)_14"),regex("(140|200)_13"),regex("550_5")},                    // ID = 4
//   {regex("(40|60|450|500)_16"),regex("(80|260|320|400)_15"),regex("(140|200)_14"),regex("550_6")},                    // ID = 5
//   {regex("(40|60|450|500)_17"),regex("(80|260|320|400)_16"),regex("(140|200)_15"),regex("550_7")},                    // ID = 6
//   {regex("(40|60|450|500)_18"),regex("(80|260|320|400)_17"),regex("(140|200)_16"),regex("550_8")},                    // ID = 7
//   {regex("(40|60|450|500)_19"),regex("(80|260|320|400)_18"),regex("(140|200)_17"),regex("550_9")}                     // ID = 8
};
//} END Switches and their settings

//{ JEC and IOV settings. In the modern world we have a group of IOV's for which different corrections are applied.
// https://github.com/cms-jet/JECDatabase/tree/master/tarballs
// Summer16_03Feb2017G_V7_DATA.tar.gz [BCD, EF, G, H]
const constexpr char _jp_jecgt[] = "Summer16_07Aug2017";//"Summer16_03Feb2017";////BCD_";//"Summer15_50ns";// "Summer16_23Sep2016";
const constexpr char _jp_jecvers[] = "_V5";//"_V9";////"V4"; // Summer16_03Feb // "V6"; // Summer16_23Sep // "V2" ; // Spring16

// Use Intervals-Of-Validity for JEC
constexpr const bool _jp_useIOV = true ;//false
constexpr const char* _jp_IOVnames[] =
//  {"BCD",    "EF",    "G",   "H"};
  {"BCD",    "EF",    "GH"};
constexpr const int _jp_nIOV = sizeof(_jp_IOVnames)/sizeof(_jp_IOVnames[0]);
// Trigger IOVs: the 1 for -inf and 400000 for inf (currently)
const constexpr int _jp_IOVranges[][2] =
  { {1,276811}, {276831,278801}, {278802,400000} }; // Summer16_23Sep2016
//  { {1,276811}, {276831,278801}, {278802,280385}, {280919,400000} }; // Spring/Summer16_23Sep2016
//} END JES and JEC


//{ BEGIN For MC reweighting purposes, PU profiles for data and MC
constexpr bool _jp_reweighPU = true;
constexpr const char _jp_pudata[] = "pileup/curr/pileup_DT.root";
constexpr const char _jp_pumc[]   = "pileup/curr/pileup_MC.root";
constexpr const double _jp_maxpu = 80.0;
//} END PU profiles


//{ BEGIN MC: Process pThatbins instead of flat sample
// All the following values need to be updated, if other source tuples are used.
// These can be obtained using getSliceEvts.C
constexpr bool _jp_pthatbins = true;//false;
// The corresponding ranges, the last number is ~inf
const vector<double> _jp_pthatranges =
  {30,50,80,120,170,300,470,600,800,1000,1400,1800,2400,3200,20000};
// Number of pthat bins
const unsigned int _jp_npthatbins = _jp_pthatranges.size()-1;
// The corresponding lumis in an arbitrary scale
const vector<double> _jp_pthatsigmas =
  {140932000,19204300,2762530,471100,117276,7823,648.2,186.9,32.293,9.4183,0.84265,0.114943,0.00682981,0.000165445};
  //{140932000,19204300,2762530,471100,117276,7823,648.2,186.9,32.293,9.4183,0.84265,0.114943,0.00682981,0.000165445};
const vector<double> _jp_pthatnevts =
  {9699558,9948791,7742665,5748730,7838066,11701816,3959986,9628335,11915305,6992746,2477018,1584378,596904,391735};
// The filenames need to be given here and in mk_histosFill, since ROOT is exceedingly stupid
const vector<string> _jp_pthatfiles = {
    "QCD_Pt_30to50_TuneCUETP8M_13TeV_pythia8.root",
    "QCD_Pt_50to80_TuneCUETP8M_13TeV_pythia8.root",
    "QCD_Pt_80to120_TuneCUETP8M_13TeV_pythia8.root",
    "QCD_Pt_120to170_TuneCUETP8M_13TeV_pythia8.root",
    "QCD_Pt_170to300_TuneCUETP8M_13TeV_pythia8.root",
    "QCD_Pt_300to470_TuneCUETP8M_13TeV_pythia8.root",
    "QCD_Pt_470to600_TuneCUETP8M_13TeV_pythia8.root",
    "QCD_Pt_600to800_TuneCUETP8M_13TeV_pythia8.root",
    "QCD_Pt_800to1000_TuneCUETP8M_13TeV_pythia8.root",
    "QCD_Pt_1000to1400_TuneCUETP8M_13TeV_pythia8.root",
    "QCD_Pt_1400to1800_TuneCUETP8M_13TeV_pythia8.root",
    "QCD_Pt_1800to2400_TuneCUETP8M_13TeV_pythia8.root",
    "QCD_Pt_2400to3200_TuneCUETP8M_13TeV_pythia8.root",
    "QCD_Pt_3200toInf_TuneCUETP8M_13TeV_pythia8.root",
};
//} END pthatbins stuff


//{ BEGIN RUN2 params
constexpr double _jp_sqrts = 13000.; // GeV
constexpr double _jp_emax = _jp_sqrts/2.; // Max possible jet pt
constexpr double _jp_recopt = 15; // Min observed jet pt
constexpr double _jp_xsecMinBias = 7.126E+10;
//} END Run2

//{ BEGIN Special histosFill analyses that are not typically needed
// Veto jets near ECAL boundaries in JetID (an older routine, kept as a reference)
constexpr bool _jp_doVetoECAL = false;//true;
const constexpr char _jp_fECALVeto[] = "lumicalc/ecalveto.root";

// Eta phi exclusion due to hot ECAL regions (produced with dataequality.C)
constexpr bool _jp_doVetoECALHot = false;
const constexpr char _jp_ECALHotType[] = "m"; // h2hotr (Robert) or h2hotm (Mikko)

// Eta phi exclusion due to hot HCAL regions (taken from
constexpr bool _jp_doVetoHCALHot = true;
constexpr const char* _jp_HCALHotRuns[] = {
  "RunB16",
  "RunC16",
  "RunD16"
};
constexpr int _jp_HCALHotEras = sizeof(_jp_HCALHotRuns)/sizeof(_jp_HCALHotRuns[0]);
constexpr const double _jp_HCALHotRanges[][4] =  {// eta{min,max}, phi(min,max}
  {-2.25,  -1.93,  2.2,   2.5},
  {-3.489, -3.139, 2.237, 2.475},
  {-3.60,  -3.139, 2.237, 2.475}
};

// Check for duplicates (warning: takes a lot of memory!)
constexpr bool _jp_checkduplicates = false;
//} END Special analyses that are not typically needed

//{ BEGIN histosNormalize (leave these off if not interested on details)
// Correct for trigger efficiency based on MC
constexpr bool _jp_dotrigeff = false; // CAUTION: Requires output-MC-1.root file
// Correct pT<114 GeV only, if above _jp_dotrigeff=true
constexpr bool _jp_dotrigefflowptonly = false; // CAUTION: Not needed
// Correct for time-dependence (prescales) in data
constexpr bool _jp_dotimedep = false; // CAUTION: Unknown consequences
//} END histosNormalize

//{ BEGIN drawSummary
// Center uncertainties around ansatz (true) or data (false)
constexpr bool _jp_centerOnAnsatz = false;
constexpr bool _jp_centerOnTheory = false;
// Plot Pythia for final PRL results
constexpr bool _jp_plotPythia = false;
// Draw againts HERAPDF1.7 instead of PDF4LHC (drawSummary)
constexpr bool _jp_herapdf = false;
// Produce plots (also drawRunHistos)
constexpr bool _jp_pdf = true;
//} END drawSummary

//{ BEGIN limits for histosNormalize, dagostini, drawSummary, drawRunHistos
// Minimum and maximum pT range to be plotted and fitted
constexpr double _jp_fitptmin = 114;//43;
// Changed on 2013-05-020: analysis from 49 GeV to 56 GeV
constexpr double _jp_xmin57 = 114;//56;
constexpr double _jp_xminpas = 114;//56;
constexpr double _jp_xmin = 114;//24.;//20.;
constexpr double _jp_xmax = 1497;//TEMP PATCH for partial data //1999.;
//} END limits

//{ BEGIN Binnings
// Binning agreed within JTF: pT>100 GeV from CaloJet resolutions,
// pT<100 GeV to optimize bin widths for PFJets and b-tagging
// (little higher than resolution, but fairly flat relative width)
// http://cmssw.cvs.cern.ch/cgi-bin/cmssw.cgi/CMSSW/QCDAnalysis/HighPtJetAnalysis/interface/DefaultPtBins.h?revision=1.2&view=markup
// Logic: 'n' means number of bins (len-1) and 'no' the length of an array (len)
constexpr const double _jp_ptrange[] = {
  1, 5, 6, 8, 10, 12, 15, 18, 21, 24, 28, 32, 37, 43, 49, 56, 64, 74, 84, 97, 114, 133, 153, 174, 196, 220, 245, 272, 300, 330, 362, 395, 430, 468, 507, 548, 592, 638, 686, 737, 790, 846, 905, 967, 1032, 1101, 1172, 1248, 1327, 1410, 1497, 1588, 1684, 1784, 1890, 2000, 2116, 2238, 2366, 2500, 2640, 2787, 2941, 3103, 3273, 3450, 3637, 3832, 4037, 4252, 4477, 4713, 4961, 5220, 5492, 5777, 6076, 6389, 6717, 7000
};
constexpr const unsigned int _jp_npts = sizeof(_jp_ptrange)/sizeof(_jp_ptrange[0])-1;

// A wide binning for pt
constexpr const double _jp_wptrange[] = {
   1, 15, 21, 28, 37, 49, 64, 84, 114, 153, 196, 245, 300, 395, 468, 548,
   686, 846, 1032, 1248, 1588, 2000, 2500, 3103, 3450, 3637, 3832,
   4037, 4252, 4477, 4713, 4961, 5220, 5492, 5777, 6076, 6389, 6717, 7000
};
constexpr const int _jp_nwpts = sizeof(_jp_wptrange)/sizeof(_jp_wptrange[0])-1;

// Even wider version of the binning for less statistical scatter for b-jets
constexpr const double _jp_wwptrange[] = {
   1, 5, 15, 24, 37, 56, 84, 114, 153, 196, 245, 330, 430, 548, 686, 846,
   1032, 1248, 1497, 1784, 2116, 2500, 2941, 3450, 3637,
   4252, 4961, 5777, 6717, 7000
};
constexpr const int _jp_nwwpts = sizeof(_jp_wwptrange)/sizeof(_jp_wwptrange[0])-1;

// Optimized binning created by optimizeBins.C ("MC"; lumi 1000/pb, eff 1e+10%)
// Using NLOxNP theory fit as input when available
constexpr const unsigned int _jp_nopts_eta = 65;
constexpr const double _jp_ptrangevseta[][_jp_nopts_eta] = {
   {10, 12, 15, 18, 21, 24, 28, 32, 37, 43, 49, 56, 64, 74, 84, 97, 114, 133, 153, 174, 196, 220, 245, 272, 300, 330, 362, 395, 430, 468, 507, 548, 592, 638, 686, 737, 790, 846, 905, 967, 1032, 1101, 1172, 1248, 1327, 1410, 1497, 1588, 1684, 1784, 1890, 2000, 2116, 2238, 2366, 2500, 2640, 2787, 2941, 3103, 3273, 3450, 3832, 6076, 6389}, // Eta_0.0-0.5
   {10, 12, 15, 18, 21, 24, 28, 32, 37, 43, 49, 56, 64, 74, 84, 97, 114, 133, 153, 174, 196, 220, 245, 272, 300, 330, 362, 395, 430, 468, 507, 548, 592, 638, 686, 737, 790, 846, 905, 967, 1032, 1101, 1172, 1248, 1327, 1410, 1497, 1588, 1684, 1784, 1890, 2000, 2116, 2238, 2366, 2500, 2640, 2787, 2941, 3103, 3273, 3637, 5220, 5492}, // Eta_0.5-1.0
   {10, 12, 15, 18, 21, 24, 28, 32, 37, 43, 49, 56, 64, 74, 84, 97, 114, 133, 153, 174, 196, 220, 245, 272, 300, 330, 362, 395, 430, 468, 507, 548, 592, 638, 686, 737, 790, 846, 905, 967, 1032, 1101, 1172, 1248, 1327, 1410, 1497, 1588, 1684, 1784, 1890, 2000, 2116, 2238, 2366, 2500, 2640, 2941, 3832}, // Eta_1.0-1.5
   {10, 12, 15, 18, 21, 24, 28, 32, 37, 43, 49, 56, 64, 74, 84, 97, 114, 133, 153, 174, 196, 220, 245, 272, 300, 330, 362, 395, 430, 468, 507, 548, 592, 638, 686, 737, 790, 846, 905, 967, 1032, 1101, 1172, 1248, 1327, 1410, 1497, 1588, 1684, 1784, 1890, 2000, 2116, 2500, 2640}, // Eta_1.5-2.0
   {10, 12, 15, 18, 21, 24, 28, 32, 37, 43, 49, 56, 64, 74, 84, 97, 114, 133, 153, 174, 196, 220, 245, 272, 300, 330, 362, 395, 430, 468, 507, 548, 592, 638, 686, 737, 790, 846, 905, 967, 1032, 1101, 1172, 1248, 1327, 1410, 1497, 1588, 1684}, // Eta_2.0-2.5
   {10, 12, 15, 18, 21, 24, 28, 32, 37, 43, 49, 56, 64, 74, 84, 97, 114, 133, 153, 174, 196, 220, 245, 272, 300, 330, 362, 395, 430, 468, 507, 548, 592, 638, 686, 737, 790, 846, 905, 967, 1032}, // Eta_2.5-3.0
   {10, 12, 15, 18, 21, 24, 28, 32, 37, 43, 49, 56, 64, 74, 84, 97, 114, 133, 153, 174, 196, 220, 245, 272, 300, 330, 362, 395, 430, 468, 507, 548, 592, 638, 686, 737, 790, 846, 905, 967, 1032}, // Eta_3.0-3.5
   {10, 12, 15, 18, 21, 24, 28, 32, 37, 43, 49, 56, 64, 74, 84, 97, 114, 133, 153, 174, 196, 220, 245, 272, 300, 330, 362, 395, 430, 468, 507, 548, 592, 638, 686, 737, 790, 846, 905, 967, 1032} // Eta_3.5-4.0
};
constexpr const unsigned int _jp_noptranges = sizeof(_jp_ptrangevseta)/sizeof(_jp_ptrangevseta[0]);

constexpr const double _jp_wetarange[] = {
   -5.191, -3.839, -3.489, -3.139, -2.964, -2.853, -2.650, -2.500, -2.322,
   -2.172, -1.930, -1.653, -1.479, -1.305, -1.044, -0.783, -0.522, -0.261,
    0.000,  0.261,  0.522,  0.783,  1.044,  1.305,  1.479,  1.653,  1.930,
    2.172,  2.322,  2.500,  2.650,  2.853,  2.964,  3.139,  3.489,  3.839, 5.191
};
constexpr const unsigned int _jp_nwetas = sizeof(_jp_wetarange)/sizeof(_jp_wetarange[0])-1;

constexpr const double _jp_posetarange[] = {
  0, 0.261, 0.522, 0.783, 0.957, 1.131, 1.305, 1.479, 1.93, 2.322, 2.411, 2.5, 2.853, 2.964, 5.191
};
constexpr const unsigned int _jp_nposetas = sizeof(_jp_posetarange)/sizeof(_jp_posetarange[0])-1;

constexpr const double _jp_etarange[] = {
   -5.191,-4.889,-4.716,-4.538,-4.363,-4.191,-4.013,-3.839,-3.664,-3.489,-3.314,
   -3.139,-2.964,-2.853,-2.65,-2.5,-2.322,-2.172,-2.043,-1.93,-1.83,-1.74,-1.653,
   -1.566,-1.479,-1.392,-1.305,-1.218,-1.131,-1.044,-0.957,-0.879,-0.783,-0.696,
   -0.609,-0.522,-0.435,-0.348,-0.261,-0.174,-0.087, 0.000, 0.087, 0.174, 0.261,
    0.348, 0.435, 0.522, 0.609, 0.696, 0.783, 0.879, 0.957, 1.044, 1.131, 1.218,
    1.305, 1.392, 1.479, 1.566, 1.653, 1.74, 1.83, 1.93, 2.043, 2.172, 2.322, 2.5,
    2.65, 2.853, 2.964, 3.139, 3.314, 3.489, 3.664, 3.839, 4.013, 4.191, 4.363,
    4.538, 4.716, 4.889, 5.191
};
constexpr const unsigned int _jp_netas = sizeof(_jp_etarange)/sizeof(_jp_etarange[0])-1;

constexpr const double _jp_pvrange[] = {
  -0.5,0.5,1.5,2.5,3.5,4.5,5.5,6.5,7.5,8.5,9.5,10.5,11.5,12.5,13.5,14.5,15.5,16.5,17.5,18.5,19.5,20.5,21.5,22.5,23.5,24.5,25.5,26.5,27.5,28.5,29.5,30.5,31.5,32.5,33.5,34.5,35.5,36.5,37.5,38.5,39.5,40.5,41.5,42.5,43.5,44.5,45.5,46.5,47.5,48.5,49.5
};
constexpr const unsigned int _jp_npvs = sizeof(_jp_pvrange)/sizeof(_jp_pvrange[0])-1;

constexpr const double _jp_phirange[] = {
  -3.15,-3.097959,-3.054326,-3.010693,-2.967060,-2.923426,-2.879793,-2.836160,-2.792527,-2.748894,-2.705260,-2.661627,-2.617994,-2.574361,-2.530727,-2.487094,-2.443461,-2.399828,-2.356194,-2.312561,-2.268928,-2.225295,-2.181662,-2.138028,-2.094395,-2.050762,-2.007129,-1.963495,-1.919862,-1.876229,-1.832596,-1.788962,-1.745329,-1.701696,-1.658063,-1.614430,-1.570796,-1.527163,-1.483530,-1.439897,-1.396263,-1.352630,-1.308997,-1.265364,-1.221730,-1.178097,-1.134464,-1.090831,-1.047198,-1.003564,-0.959931,-0.916298,-0.872665,-0.829031,-0.785398,-0.741765,-0.698132,-0.654498,-0.610865,-0.567232,-0.523599,-0.479966,-0.436332,-0.392699,-0.349066,-0.305433,-0.261799,-0.218166,-0.174533,-0.130900,-0.087266,-0.043633,0.000000,0.043633,0.087266,0.130900,0.174533,0.218166,0.261799,0.305433,0.349066,0.392699,0.436332,0.479966,0.523599,0.567232,0.610865,0.654498,0.698132,0.741765,0.785398,0.829031,0.872665,0.916298,0.959931,1.003564,1.047198,1.090831,1.134464,1.178097,1.221730,1.265364,1.308997,1.352630,1.396263,1.439897,1.483530,1.527163,1.570796,1.614430,1.658063,1.701696,1.745329,1.788962,1.832596,1.876229,1.919862,1.963495,2.007129,2.050762,2.094395,2.138028,2.181662,2.225295,2.268928,2.312561,2.356194,2.399828,2.443461,2.487094,2.530727,2.574361,2.617994,2.661627,2.705260,2.748894,2.792527,2.836160,2.879793,2.923426,2.967060,3.010693,3.054326,3.097959,3.15
};
constexpr const unsigned int _jp_nphis = sizeof(_jp_phirange)/sizeof(_jp_phirange[0])-1;

constexpr const double _jp_posphirange[] = {
 0.000000,0.021817,0.043633,0.065450,0.087266,0.109083,0.130900,0.152716,0.174533,0.196350,0.218166,0.239983,0.261799,0.283616,0.305433,0.327249,0.349066,0.370882,0.392699,0.414516,0.436332,0.458149,0.479966,0.501782,0.523599,0.545415,0.567232,0.589049,0.610865,0.632682,0.654498,0.676315,0.698132,0.719948,0.741765,0.763582,0.785398,0.807215,0.829031,0.850848,0.872665,0.894481,0.916298,0.938114,0.959931,0.981748,1.003564,1.025381,1.047198,1.069014,1.090831,1.112647,1.134464,1.156281,1.178097,1.199914,1.221730,1.243547,1.265364,1.287180,1.308997,1.330814,1.352630,1.374447,1.396263,1.418080,1.439897,1.461713,1.483530,1.505346,1.527163,1.548980,1.570796,1.592613,1.614430,1.636246,1.658063,1.679879,1.701696,1.723513,1.745329,1.767146,1.788962,1.810779,1.832596,1.854412,1.876229,1.898046,1.919862,1.941679,1.963495,1.985312,2.007129,2.028945,2.050762,2.072578,2.094395,2.116212,2.138028,2.159845,2.181662,2.203478,2.225295,2.247111,2.268928,2.290745,2.312561,2.334378,2.356194,2.378011,2.399828,2.421644,2.443461,2.465278,2.487094,2.508911,2.530727,2.552544,2.574361,2.596177,2.617994,2.639810,2.661627,2.683444,2.705260,2.727077,2.748894,2.770710,2.792527,2.814343,2.836160,2.857977,2.879793,2.901610,2.923426,2.945243,2.967060,2.988876,3.010693,3.032510,3.054326,3.076143,3.097959,3.119776,3.15
};
constexpr const unsigned int _jp_nposphis = sizeof(_jp_posphirange)/sizeof(_jp_posphirange[0])-1;

constexpr const double _jp_wphirange[] = {
  -3.15,-2.96706,-2.79253,-2.61799,-2.44346,-2.26893,-2.0944,-1.91986,-1.74533,-1.5708,-1.39626,-1.22173,-1.0472,-0.872665,-0.698132,-0.523599,-0.349066,-0.174533,0,0.174533,0.349066,0.523599,0.698132,0.872665,1.0472,1.22173,1.39626,1.5708,1.74533,1.91986,2.0944,2.26893,2.44346,2.61799,2.79253,2.96706,3.15
};
constexpr const unsigned int _jp_nwphis = sizeof(_jp_wphirange)/sizeof(_jp_wphirange[0])-1;

constexpr const double _jp_wposphirange[] = {
  0,0.0872665,0.174533,0.261799,0.349066,0.436332,0.523599,0.610865,0.698132,0.785398,0.872665,0.959931,1.0472,1.13446,1.22173,1.309,1.39626,1.48353,1.5708,1.65806,1.74533,1.8326,1.91986,2.00713,2.0944,2.18166,2.26893,2.35619,2.44346,2.53073,2.61799,2.70526,2.79253,2.87979,2.96706,3.05433,3.15
};
constexpr const unsigned int _jp_nwposphis = sizeof(_jp_wposphirange)/sizeof(_jp_wposphirange[0])-1;

//} END Binnings

#endif // __settings_h__
